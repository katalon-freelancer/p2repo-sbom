# Vulnerability Information Integration for CycloneDX SBOM

This document describes how vulnerability information can be embedded into the CycloneDX XML format produced by the SBOM generator.

## Overview

CycloneDX SBOM format supports vulnerability information through the `Vulnerability` model class. This document identifies:
1. Code locations where vulnerability information can be injected
2. CVE data sources that can be queried via APIs

## Code Injection Points

### 1. Component Creation from Maven Artifacts

**Location**: `SBOMApplication.java` - Method `createMavenJarComponent(String path, MavenDescriptor mavenDescriptor, byte[] bytes)`

**Line**: ~1012-1024

```java
private Component createMavenJarComponent(String path, MavenDescriptor mavenDescriptor, byte[] bytes) {
    var component = new Component();
    component.setType(Component.Type.LIBRARY);
    if (setMavenPurl(component, mavenDescriptor, bytes)) {
        // If it's verified to be the identical artifact.
        component.setName(mavenDescriptor.artifactId());
        component.setGroup(mavenDescriptor.groupId());
    } else {
        // If it's got a pedigree, use the original jar path.
        component.setName(path);
    }
    // INJECTION POINT: After component creation, query CVE databases using:
    // - mavenDescriptor.groupId()
    // - mavenDescriptor.artifactId()
    // - mavenDescriptor.version()
    // - Hash computed from bytes (SHA-1, SHA-256, etc.)
    return component;
}
```

**What's available for CVE lookup**:
- Maven GAV coordinates: `groupId`, `artifactId`, `version`
- Binary hash (can be computed using `BOMUtil.computeHash(algorithm, bytes)`)
- Package URL (PURL) after `setMavenPurl()` is called

### 2. Setting Maven PURL on Component

**Location**: `SBOMApplication.java` - Method `setMavenPurl(Component component, MavenDescriptor mavenDescriptor, byte[] bytes)`

**Line**: ~1171-1206

```java
private boolean setMavenPurl(Component component, MavenDescriptor mavenDescriptor, byte[] bytes) {
    try {
        var mavenArtifactBytes = contentHandler.getBinaryContent(mavenDescriptor.toArtifactURI());
        getClearlyDefinedProperty(component, mavenDescriptor);
        
        var differences = new ArrayList<String>();
        if (equivalent(bytes, mavenArtifactBytes, differences)) {
            var purl = mavenDescriptor.mavenPURL();
            component.setPurl(purl);
            // INJECTION POINT: After PURL is set, query vulnerability databases
            // using the Maven coordinates or PURL itself
            return true;
        }
        // ...
    } catch (ContentHandler.ContentHandlerException e) {
        // ...
    }
    return false;
}
```

**What's available for CVE lookup**:
- Maven PURL (Package URL) format: `pkg:maven/groupId/artifactId@version`
- Binary content for hash-based lookups
- Already validated that artifact exists in Maven Central

### 3. Creating Ancestor Components (Pedigree)

**Location**: `SBOMApplication.java` - Method `createAncestorComponent(MavenDescriptor mavenDescriptor)`

**Line**: ~1003-1010

```java
private Component createAncestorComponent(MavenDescriptor mavenDescriptor) {
    var component = new Component();
    component.setType(Component.Type.LIBRARY);
    component.setName(mavenDescriptor.artifactId());
    component.setGroup(mavenDescriptor.groupId());
    component.setPurl(mavenDescriptor.mavenPURL());
    // INJECTION POINT: Query vulnerabilities for ancestor component
    return component;
}
```

**What's available for CVE lookup**:
- Maven coordinates
- Maven PURL

### 4. General Component Creation from P2 Installable Units

**Location**: `SBOMApplication.java` - Method `createComponent(IInstallableUnit iu)`

**Line**: ~1034-1114

```java
private Component createComponent(IInstallableUnit iu) {
    var component = new Component();
    component.setName(iu.getId());
    component.setType(Component.Type.LIBRARY);
    component.setVersion(iu.getVersion().toString());
    // ... (setting properties, licenses, etc.)
    
    // INJECTION POINT: After component is fully populated, check if it has
    // Maven properties and query vulnerabilities. Look for:
    // - Properties starting with "maven-"
    // - PURL if already set
    // - Hash values if computed
    
    return component;
}
```

### 5. Gathering License Information from POM

**Location**: `SBOMApplication.java` - Method `gatherInformationFromPOM(Component component, Document document, Map<String, String> licenseToName)`

**Line**: ~1608-1685

```java
private void gatherInformationFromPOM(Component component, Document document,
        Map<String, String> licenseToName) {
    // ... (gathering licenses, SCM, issues)
    
    // INJECTION POINT: While processing POM, we have access to the Maven document
    // which contains groupId, artifactId, version. This is a good place to
    // query vulnerability databases after all POM information is gathered.
}
```

### 6. After Hash Computation

**Location**: `SBOMApplication.java` - Method `getArtifactContent(Component component, IArtifactDescriptor artifactDescriptor)`

**Line**: ~1309-1322

```java
private byte[] getArtifactContent(Component component, IArtifactDescriptor artifactDescriptor) {
    var isMetadata = isMetadata(artifactDescriptor);
    byte[] bytes;
    if (isMetadata) {
        bytes = new byte[0];
        component.setType(Type.DATA);
    } else {
        component.setData(List.of());
        bytes = getArtifactBytes(getCompositeArtifactRepository(), artifactDescriptor);
        addHashes(component, bytes);
        // INJECTION POINT: After hashes are added to component,
        // query vulnerability databases using the hash values
        // (available via component.getHashes())
    }
    return bytes;
}
```

## CVE Data Sources with APIs

### 1. OSV (Open Source Vulnerabilities)

**API**: https://osv.dev/

**Query Methods**:
- By Package (Maven): `POST https://api.osv.dev/v1/query`
  ```json
  {
    "package": {
      "name": "artifactId",
      "ecosystem": "Maven"
    },
    "version": "1.0.0"
  }
  ```
- By Hash: `POST https://api.osv.dev/v1/query`
  ```json
  {
    "commit": "hash_value"
  }
  ```

**Advantages**:
- Free and open-source
- Comprehensive coverage across ecosystems (Maven, npm, PyPI, etc.)
- Well-documented REST API
- No authentication required for basic queries
- Returns vulnerabilities in OSV format (easily convertible to CycloneDX)

**Rate Limits**: Reasonable for batch processing

### 2. National Vulnerability Database (NVD)

**API**: https://nvd.nist.gov/developers/vulnerabilities

**Query Methods**:
- By CPE (Common Platform Enumeration): `GET https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:a:vendor:product:version`
- By Keyword: `GET https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=artifactId`

**Advantages**:
- Official US government database
- Comprehensive CVE information
- Free API access

**Limitations**:
- Requires API key for higher rate limits
- No direct Maven coordinate lookup (requires CPE translation)
- Rate limited without API key (5 requests per 30 seconds)

**Note**: Need to construct CPE from Maven coordinates, which can be complex.

### 3. Sonatype OSS Index

**API**: https://ossindex.sonatype.org/

**Query Methods**:
- By Package URL: `POST https://ossindex.sonatype.org/api/v3/component-report`
  ```json
  {
    "coordinates": [
      "pkg:maven/groupId/artifactId@version"
    ]
  }
  ```

**Advantages**:
- Free for limited use (without authentication)
- Direct PURL support (perfect for our use case)
- Maven-specific database
- Returns vulnerability information directly

**Rate Limits**: 
- Unauthenticated: 16 requests per hour
- Authenticated (free account): Higher limits

### 4. GitHub Advisory Database

**API**: https://api.github.com/graphql

**Query Methods**:
- GraphQL query for vulnerabilities:
  ```graphql
  query {
    securityVulnerabilities(ecosystem: MAVEN, package: "groupId:artifactId", first: 100) {
      nodes {
        advisory {
          ghsaId
          summary
          severity
        }
        vulnerableVersionRange
      }
    }
  }
  ```

**Advantages**:
- Free access via GitHub API
- Good coverage for open-source projects
- Includes GHSA (GitHub Security Advisory) IDs
- Can be correlated with repository information already gathered

**Limitations**:
- Requires GitHub token for higher rate limits
- GraphQL interface (more complex than REST)

### 5. Snyk Vulnerability Database

**API**: https://snyk.io/api/

**Query Methods**:
- By Maven coordinates: `GET https://snyk.io/api/v1/test/maven/groupId/artifactId/version`

**Advantages**:
- Comprehensive commercial-grade database
- Maven-specific support
- High-quality vulnerability data with fix recommendations

**Limitations**:
- Requires API token (free tier available)
- Commercial product with usage limits

### 6. deps.dev (Google)

**API**: https://deps.dev/

**Query Methods**:
- By Package: `GET https://api.deps.dev/v3alpha/systems/maven/packages/{groupId}:{artifactId}`
- Version details: `GET https://api.deps.dev/v3alpha/systems/maven/packages/{groupId}:{artifactId}/versions/{version}`

**Advantages**:
- Free Google service
- Includes vulnerability information
- Maven coordinate support
- Transitive dependency analysis

**Rate Limits**: Generous for open-source projects

### 7. Sonatype CVE Data (via Maven Central Search)

**API**: https://central.sonatype.com/

**Query Methods**:
- The code already uses: `https://central.sonatype.com/solrsearch/select?q=1:{sha1Hash}&wt=json`
- Extension possible to query vulnerability information

**Advantages**:
- Already integrated in the codebase for Maven artifact lookup
- Direct hash-based lookup support
- No additional authentication needed

**Note**: This is used in `createFromBytes()` method around line 1982-2014.

## Recommended Implementation Approach

### Phase 1: OSV Integration (Recommended First Step)

1. Add OSV API client to query by Maven coordinates
2. Inject vulnerability queries in `setMavenPurl()` method
3. Convert OSV vulnerability format to CycloneDX `Vulnerability` objects
4. Add vulnerabilities to components using `component.setVulnerabilities()`

**Why OSV First**:
- No authentication required
- Free and open-source
- Direct Maven support
- Well-documented API
- Good rate limits

### Phase 2: Hash-Based Lookup

1. Use OSV or deps.dev for hash-based queries
2. Inject after `addHashes()` is called in `getArtifactContent()`
3. Fallback mechanism when Maven coordinates are not available

### Phase 3: Multiple Source Aggregation

1. Query multiple sources (OSV, GitHub Advisory, deps.dev)
2. Deduplicate CVE entries
3. Aggregate severity scores
4. Add source attribution in vulnerability metadata

## CycloneDX Vulnerability Model

To add vulnerabilities to a component, use the CycloneDX library:

```java
import org.cyclonedx.model.vulnerability.Vulnerability;
import org.cyclonedx.model.vulnerability.Vulnerability.Rating;
import org.cyclonedx.model.vulnerability.Vulnerability.Source;

// Create vulnerability
var vulnerability = new Vulnerability();
vulnerability.setId("CVE-2023-12345");
vulnerability.setSource(createSource("OSV"));
vulnerability.setDescription("Description of the vulnerability");

// Add rating
var rating = new Rating();
rating.setScore(7.5);
rating.setSeverity(Rating.Severity.HIGH);
rating.setMethod(Rating.Method.CVSSV3);
vulnerability.addRating(rating);

// Add to component
component.addVulnerability(vulnerability);
```

**Note**: Need to verify the exact CycloneDX API in the version used by this project. May need to add import for vulnerability classes in MANIFEST.MF.

## Implementation Considerations

1. **Performance**: Vulnerability queries can be slow. Consider:
   - Caching results
   - Batch queries where supported
   - Async/parallel processing
   - Optional feature (command-line flag)

2. **Error Handling**: API failures should not break SBOM generation
   - Graceful degradation
   - Log warnings for failed lookups
   - Continue processing other components

3. **Rate Limiting**: Implement exponential backoff and respect rate limits

4. **Configuration**: Add command-line options:
   - `--query-vulnerabilities`: Enable vulnerability lookup
   - `--vulnerability-source=osv|nvd|github|all`: Choose source
   - `--vulnerability-cache-dir`: Cache directory for results

5. **Testing**: Add tests with mocked API responses to avoid actual API calls during testing

## Next Steps

1. Review CycloneDX library version to confirm `Vulnerability` API availability
2. Add necessary imports to `MANIFEST.MF` if needed
3. Create helper class `VulnerabilityQuerier` to encapsulate API calls
4. Implement OSV integration as proof of concept
5. Add configuration options for enabling/disabling vulnerability queries
6. Update documentation and examples
